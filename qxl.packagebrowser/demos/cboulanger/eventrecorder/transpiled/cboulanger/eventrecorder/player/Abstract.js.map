{
  "version": 3,
  "sources": [
    "/home/runner/work/qxl.packagebrowser/qxl.packagebrowser/packages/qx_packages/cboulanger_eventrecorder_v0_18_0/source/class/cboulanger/eventrecorder/player/Abstract.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "include",
    "cboulanger",
    "eventrecorder",
    "MState",
    "MHelperMethods",
    "statics",
    "utilityFunctions",
    "waitForCondition",
    "fn",
    "interval",
    "timeout",
    "timeoutMsg",
    "Promise",
    "resolve",
    "reject",
    "intervalId",
    "setInterval",
    "clearInterval",
    "setTimeout",
    "Error",
    "waitForEvent",
    "qxObjOrId",
    "type",
    "expectedData",
    "qxObj",
    "lang",
    "Type",
    "isString",
    "Id",
    "getQxObject",
    "getTimeout",
    "timeoutId",
    "removeListener",
    "changeEventHandler",
    "e",
    "app",
    "Init",
    "getApplication",
    "eventdata",
    "event",
    "Data",
    "getData",
    "undefined",
    "warn",
    "addListenerOnce",
    "isArray",
    "length",
    "index",
    "expectedItem",
    "entries",
    "JSON",
    "stringify",
    "isRegExp",
    "match",
    "toString",
    "info",
    "clearTimeout",
    "properties",
    "mode",
    "check",
    "init",
    "apply",
    "useDefaultDelay",
    "nullable",
    "maxDelay",
    "canReplayInBrowser",
    "canExportExecutableCode",
    "macros",
    "events",
    "construct",
    "__commands",
    "_globalRef",
    "window",
    "resetMacros",
    "name",
    "members",
    "__macro_stack",
    "__macro_stack_index",
    "__vars",
    "__promises",
    "__lastId",
    "__lastCmd",
    "getType",
    "getLastId",
    "getLastCommand",
    "_applyMode",
    "value",
    "old",
    "_addCommands",
    "commands",
    "concat",
    "sort",
    "a",
    "b",
    "getCommands",
    "getMacros",
    "dispose",
    "data",
    "marshal",
    "Json",
    "createModel",
    "names",
    "definitions",
    "descriptions",
    "setMacros",
    "macroExists",
    "getNames",
    "indexOf",
    "getMacroNames",
    "getMacroDefinition",
    "getDefinitions",
    "getItem",
    "getMacroDescription",
    "getDescriptions",
    "addMacro",
    "description",
    "push",
    "beginMacroDefintion",
    "isInMacroDefinition",
    "getCurrentMacroName",
    "leaveMacroDefinition",
    "_translateLine",
    "line",
    "trim",
    "startsWith",
    "addComment",
    "substr",
    "command",
    "args",
    "tokenize",
    "String",
    "toLocaleLowerCase",
    "method_name",
    "replace",
    "translatedLine",
    "then",
    "message",
    "Array",
    "isInAwaitBlock",
    "_addPromiseToAwaitStack",
    "_handleMeta",
    "script",
    "expandVariables",
    "lines",
    "split",
    "var_def",
    "_getMacro",
    "macro_name",
    "macro_lines",
    "i",
    "map",
    "l",
    "RegExp",
    "_defineVariables",
    "getOwnPropertyNames",
    "key",
    "_translateVariables",
    "var_name",
    "var_content",
    "_generateUtilityFunctionsCode",
    "filter",
    "Boolean",
    "join",
    "_play",
    "steps",
    "step",
    "getRunning",
    "debug",
    "fireDataEvent",
    "getMode",
    "code",
    "repeat",
    "result",
    "eval",
    "replay",
    "scriptOrLines",
    "setRunning",
    "await_block",
    "qxl",
    "dialog",
    "Dialog",
    "error",
    "Timer",
    "once",
    "cmd_hide_info",
    "translate",
    "_translate",
    "includeUtilityFunctions",
    "translatedLines",
    "new_lines",
    "translation",
    "generateWaitForConditionCode",
    "condition",
    "timeoutmsg",
    "Assert",
    "assertString",
    "getInterval",
    "generateWaitForEventCode",
    "id",
    "generateWaitForEventTimoutFunction",
    "comment",
    "escapeRegexpChars",
    "s",
    "createRegexpForJsonComparison",
    "searchExp",
    "foundRegExps",
    "m",
    "slice",
    "promiseCode",
    "getExportFileExtension",
    "_getStorage",
    "bom",
    "storage",
    "Web",
    "getSession",
    "_saveImport",
    "uri",
    "setItem",
    "_getImport",
    "_clearImports",
    "forEach",
    "removeItem",
    "cmd_import",
    "remoteScript",
    "getRawGist",
    "cmd_clear_imports",
    "cmd_assert_uri",
    "cmd_assert_match_uri",
    "uri_regexp",
    "cmd_config_set_mode",
    "cmd_define",
    "macro_description",
    "cmd_end",
    "cmd_await_all",
    "player",
    "Abstract"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n  UI Event Recorder\n\n  Copyright:\n    2018 Christian Boulanger\n\n  License:\n    MIT license\n    See the LICENSE file in the project's top-level directory for details.\n\n  Authors: Christian Boulanger\n\n************************************************************************ */\n\n/**\n * The base class of all player types\n * @require(qx.bom.Element)\n */\nqx.Class.define(\"cboulanger.eventrecorder.player.Abstract\", {\n  extend : qx.core.Object,\n  include : [\n    cboulanger.eventrecorder.MState,\n    cboulanger.eventrecorder.MHelperMethods\n  ],\n\n  statics: {\n    utilityFunctions : {\n      /**\n       * Runs the given function in the interval until it returns true or the\n       * given timeout is reached. Returns a promise that will resolve once the\n       * function returns true or rejects if the timeout is reached.\n       * @param fn {Function} Condition function\n       * @param interval {Number} The interval in which to run the function. Defaults to 100 ms.\n       * @param timeout {Number} The timeout in milliseconds. Defaults to 10 seconds\n       * @param timeoutMsg {String|undefined} An optional addition to the timeout error message\n       * @return {Promise}\n       */\n      waitForCondition: function(fn, interval=100, timeout=10000, timeoutMsg) {\n        return new Promise(((resolve, reject) => {\n          let intervalId = setInterval(() => {\n            if (fn()) {\n              clearInterval(intervalId);\n              resolve();\n            }\n          }, interval);\n          setTimeout(() => {\n            clearInterval(intervalId);\n            reject(new Error(timeoutMsg || `Timeout waiting for condition.`));\n          }, timeout);\n        }));\n      },\n\n      /**\n       * Returns a promise that will resolve (with any potential event data) if\n       * the given object fires an event with the given type and will reject if\n       * the timeout is reached before that happens.\n       *\n       * @param qxObjOrId {qx.core.Object|String} If string, assume it is the object id\n       * @param type {String} Type of the event\n       * @param expectedData {*|undefined} The data to expect. If undefined,\n       * resolve. If a regular expression, the event data as a JSON literal will\n       * be matched with that regex and the promise will resolve when it matches.\n       * Otherwise, the data will be compared with the actual event data both\n       * serialized to JSON.\n       * @param timeout {Number|undefined} The timeout in milliseconds. Defaults to 10 seconds\n       * @param timeoutMsg {String|undefined} An optional addition to the timeout error message\n       * @return {Promise}\n       */\n      waitForEvent: function(qxObjOrId, type, expectedData, timeout, timeoutMsg) {\n        let qxObj = qxObjOrId;\n        if (qx.lang.Type.isString(qxObjOrId)) {\n          qxObj = qx.core.Id.getQxObject(qxObjOrId);\n          if (!qxObj) {\n            throw new Error(`Invalid object id ${qxObjOrId}`);\n          }\n        }\n        timeout = timeout || this.getTimeout();\n\n        return new Promise(((resolve, reject) => {\n          // create a timeout\n          let timeoutId = setTimeout(() => {\n            qxObj.removeListener(type, changeEventHandler);\n            reject(new Error(timeoutMsg || `Timeout waiting for event \"${type}.`));\n          }, timeout);\n\n          // function to create a listener for the change event\n          let changeEventHandler = e => {\n            let app = qx.core.Init.getApplication();\n            let eventdata = e instanceof qx.event.type.Data ? e.getData() : undefined;\n            if (expectedData !== undefined) {\n              if (eventdata === undefined) {\n                app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, received 'undefined'`);\n                qxObj.addListenerOnce(type, changeEventHandler);\n                return;\n              }\n              if (qx.lang.Type.isArray(expectedData) && qx.lang.Type.isArray(eventdata) && expectedData.length && expectedData[0] instanceof qx.core.Object) {\n                /** a) either match array and check for \"live\" qooxdoo objects in the array (this is for selections), */\n                for (let [index, expectedItem] of expectedData.entries()) {\n                  if (expectedItem !== eventdata[index]) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, received non-matching array of qooxdoo objects!`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                }\n              } else {\n                // convert event data to JSON\n                try {\n                  eventdata = JSON.stringify(e.getData());\n                } catch (e) {\n                  throw new Error(`\\n--- When waiting for event '${type}' on object ${qxObj}, could not stringify event data for comparison.`);\n                }\n                if (qx.lang.Type.isRegExp(expectedData)) {\n                  /** b) or match a regular expression, */\n                  if (!eventdata.match(expectedData)) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, expected data to match '${expectedData.toString()}', got ${eventdata}!`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                } else {\n                  /* c) or compare JSON equality */\n                  try {\n                    expectedData = JSON.stringify(expectedData);\n                  } catch (e) {\n                    throw new Error(`When waiting for event '${type}' on object ${qxObj}, could not stringify expected data for comparison.`);\n                  }\n                  if (eventdata !== expectedData) {\n                    app.warn(`\\n--- When waiting for event '${type}' on object ${qxObj}, expected '${JSON.stringify(expectedData)}', got '${JSON.stringify(eventdata)}'!\"`);\n                    qxObj.addListenerOnce(type, changeEventHandler);\n                    return;\n                  }\n                }\n              }\n            }\n            app.info(`\\n+++ Received correct event '${type}' on object ${qxObj}.\"`);\n            clearTimeout(timeoutId);\n            resolve(eventdata);\n          };\n\n          // add a listener\n          qxObj.addListenerOnce(type, changeEventHandler);\n        }));\n      }\n    }\n  },\n\n  properties: {\n    /**\n     * The replay mode. Possible values:\n     * \"test\": The script is executed ignoring the \"delay\" commands, errors will\n     * stop execution and will be thrown.\n     * \"presentation\": The script is executed with user delays, errors will be\n     * logged to the console but will not stop execution\n     */\n    mode: {\n      check: [\"test\", \"presentation\"],\n      event: \"changeMode\",\n      init: \"presentation\",\n      apply: \"_applyMode\"\n    },\n\n    /**\n     * The timeout in milliseconds\n     */\n    timeout: {\n      check: \"Number\",\n      init: 10000\n    },\n\n    /**\n     * The interval between checks if waiting for a condition to fulfil\n     */\n    interval: {\n      check: \"Number\",\n      init: 100\n    },\n\n    /**\n     * if true, ignore user delays and use defaultDelay\n     */\n    useDefaultDelay: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false\n    },\n\n    /**\n     * The maximun delay between events (limits user-generated delay)\n     */\n    maxDelay: {\n      check: \"Number\",\n      init: 1000\n    },\n\n    /**\n     * Whether the player can replay the generated script in the browser\n     */\n    canReplayInBrowser: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false,\n      event: \"changeCanReplay\"\n    },\n\n    /**\n     * Whether the player can export code that can be used outside this application\n     */\n    canExportExecutableCode: {\n      check: \"Boolean\",\n      nullable: false,\n      init: false,\n      event: \"changeCanExportExecutableCode\"\n    },\n\n    /**\n     * Macro data\n     */\n    macros: {\n      check: \"qx.core.Object\",\n      init: null,\n      event: \"changeMacros\"\n    }\n  },\n\n  events: {\n    /**\n     * Fired with each step of the replayed script. The event data is an array\n     * containing the number of the step and the number of steps\n     */\n    \"progress\" : \"qx.event.type.Data\"\n  },\n\n  /**\n   * constructor\n   */\n  construct: function() {\n    this.base(arguments);\n    this.__commands = [];\n    this._globalRef = \"eventrecorder_player\";\n    window[this._globalRef] = this;\n    this.resetMacros();\n    // inject utility functions in the statics section into the global scope\n    // so that they are available in eval()\n    for (let [name, fn] of Object.entries(this.self(arguments).utilityFunctions)) {\n      window[name] = fn;\n    }\n  },\n\n  /**\n   * The methods and simple properties of this class\n   */\n  members :\n  {\n    /**\n     * A globally accessible reference to the player implementation\n     */\n    _globalRef: null,\n\n    /**\n     * A list of available commands\n     */\n    __commands: null,\n\n    /**\n     * An array of object containing information on the macros that are currently\n     * being defined (in a nested way)\n     * @var {Object[]}\n     */\n    __macro_stack: null,\n\n    /**\n     * The index of the macro in the macro stack that is currently defined\n     * @var {Integer}\n     */\n    __macro_stack_index: -1,\n\n    /**\n     * Variables\n     */\n    __vars: null,\n\n    /**\n     * An array of promises which are to be awaited\n     */\n    __promises: null,\n\n    /**\n     * Last id addressed\n     */\n    __lastId : null,\n\n    /**\n     * Last command used\n     */\n    __lastCmd : null,\n\n    /**\n     * Returns the player type\n     * @return {String}\n     */\n    getType() {\n      throw new Error(\"Abstract method which needs to be implemented\");\n    },\n\n    /**\n     * Return the last id used\n     * @return {String|null}\n     */\n    getLastId() {\n      return this.__lastId;\n    },\n\n    /**\n     * Return the last command used\n     * @return {String|null}\n     */\n    getLastCommand() {\n      return this.__lastCmd;\n    },\n\n    /**\n     * Stub to be overridden if needed\n     * @param value\n     * @param old\n     * @private\n     */\n    _applyMode(value, old) {},\n\n    /**\n     * NOT IMPLEMENTED\n     * Adds the given array of commands\n     * @param commands {Object[]}\n     */\n    _addCommands(commands) {\n      this.__commands = this.__commands.concat(commands).sort((a, b) => a.name > b.name);\n    },\n\n    /**\n     * NOT IMPLEMENTED\n     * Returns the list of availabe commands\n     * @return {Object[]}\n     */\n    getCommands() {\n      return this.__commands;\n    },\n\n    /**\n     * Clears all macro definitions and the macro stack\n     */\n    resetMacros() {\n      if (this.getMacros()) {\n        this.getMacros().dispose();\n      }\n      this.__macro_stack = [];\n      this.__macro_stack_index = -1;\n      let macros = qx.data.marshal.Json.createModel({\n        names: [],\n        definitions: [],\n        descriptions: []\n      }, true);\n      this.setMacros(macros);\n    },\n\n    /**\n     * Returns true if a macro of that name exists.\n     * @param name {String}\n     * @return {boolean}\n     */\n    macroExists(name) {\n      return this.getMacros().getNames().indexOf(name) >= 0;\n    },\n\n    /**\n     * Returns the names of the currently defined macros as a qx.data.Array\n     * @return {qx.data.Array}\n     */\n    getMacroNames() {\n      return this.getMacros().getNames();\n    },\n\n    /**\n     * Returns an array with the lines of the macro of that name\n     * @param name {String}\n     * @return {Array}\n     */\n    getMacroDefinition(name) {\n      let index = this.getMacros().getNames().indexOf(name);\n      if (index < 0) {\n        throw new Error(`Macro '${name}' does not exist`);\n      }\n      return this.getMacros().getDefinitions().getItem(index);\n    },\n\n    /**\n     * Returns the description of the macro\n     * @param name {String}\n     * @return {String}\n     */\n    getMacroDescription(name) {\n      let index = this.getMacros().getNames().indexOf(name);\n      if (index < 0) {\n        throw new Error(`Macro '${name}' does not exist`);\n      }\n      return this.getMacros().getDescriptions().getItem(index);\n    },\n\n    /**\n     * Adds an empty macro of this name\n     * @param name {String}\n     * @param description {String|undefined}\n     */\n    addMacro(name, description) {\n      if (this.macroExists(name)) {\n        throw new Error(`A macro of the name '${name}' alread exists.`);\n      }\n      let macros = this.getMacros();\n      macros.getDefinitions().push([]);\n      macros.getDescriptions().push(description||\"\");\n      macros.getNames().push(name);\n    },\n\n    /**\n     * Begins the definition of a macro of that name.\n     * @param name {String}\n     */\n    beginMacroDefintion(name) {\n      let index = ++this.__macro_stack_index;\n      this.__macro_stack[index] = { name };\n    },\n\n    /**\n     * Returns true if the player is currently in a macro definition\n     * @return {boolean}\n     */\n    isInMacroDefinition() {\n      return this.__macro_stack_index >= 0;\n    },\n\n    /**\n     * Return the name of the macro that is currently being defined\n     * @return {String}\n     */\n    getCurrentMacroName() {\n      if (!this.isInMacroDefinition()) {\n        throw new Error(\"No macro is currently defined\");\n      }\n      let {name} = this.__macro_stack[this.__macro_stack_index];\n      return name;\n    },\n\n    /**\n     * Leave the current macro, i.e. return to the including script/macro\n     */\n    leaveMacroDefinition() {\n      this.getCurrentMacroName(); // this will throw if none is being defined\n      this.__macro_stack_index--;\n    },\n\n    /**\n     * Translates a single line from the intermediate code into the target\n     * language. To be overridden by subclasses if neccessary. Returns a\n     * single line in most cases, an array of lines in case of imports.\n     *\n     * @param line {String}\n     * @return {String|String[]}\n     * @ignore(command)\n     * @ignore(args)\n     */\n    async _translateLine(line) {\n      line = line.trim();\n      if (!line) {\n        return null;\n      }\n      // comment\n      if (line.startsWith(\"#\")) {\n        return this.addComment(line.substr(1).trim());\n      }\n      // parse command line\n\n      let [command, ...args] = this.tokenize(line);\n      command = String(command).toLocaleLowerCase();\n      this.__lastCmd = command;\n      this.__lastId = args[0]; // assume first argument is id\n      // run command generation implementation\n      let method_name = \"cmd_\" + command.replace(/-/g, \"_\");\n      if (typeof this[method_name] == \"function\") {\n        let translatedLine;\n        try {\n          translatedLine = this[method_name].apply(this, args);\n          // async function\n          if (translatedLine && typeof translatedLine.then == \"function\") {\n            translatedLine = await translatedLine;\n          }\n        } catch (e) {\n          throw new Error(`Error translating '${line}': ${e.message}`);\n        }\n        // imports\n        if (Array.isArray(translatedLine)) {\n          return translatedLine;\n        }\n        if (translatedLine && translatedLine.startsWith(\"(\") && this.isInAwaitBlock()) {\n          this._addPromiseToAwaitStack(translatedLine);\n          return null;\n        }\n        return translatedLine;\n      }\n      throw new Error(`Unsupported/unrecognized command: '${command}'`);\n    },\n\n    /**\n     * Given a script, return an array of lines with all variable and macro\n     * declarations registered and removed. Optionally, variables are expanded.\n     *\n     * @param script {String}\n     * @param expandVariables {Boolean} Whether to expand the found variables. Default to true\n     * @return {Array}\n     * @private\n     */\n    async _handleMeta(script, expandVariables=true) {\n      this.resetMacros();\n      this.__vars = {};\n      let lines = [];\n      for (let line of script.split(/\\n/)) {\n        line = line.trim();\n        if (!line) {\n          continue;\n        }\n        // expand variables\n        let var_def = line.match(/([^=\\s]+)\\s*=\\s*(.+)/);\n        if (var_def) {\n          this.__vars[var_def[1]] = var_def[2];\n          continue;\n        } else if (expandVariables && line.match(/\\$([^\\s\\d\\/]+)/)) {\n          line = line.replace(/\\$([^\\s\\d\\/]+)/g, (...args) => this.__vars[args[1]]);\n        }\n\n        // register macros\n        if (line.startsWith(\"define \")) {\n          if (this.isInAwaitBlock()) {\n            throw new Error(\"You cannot use a macro in an await block.\");\n          }\n          await this._translateLine(line);\n          continue;\n        }\n\n        // await block\n        if (line.startsWith(\"await-\")) {\n          await this._translateLine(line);\n        }\n\n        // end await block or macro\n        if (line === \"end\") {\n          // macro\n          if (!this.isInAwaitBlock()) {\n            await this._translateLine(line);\n            continue;\n          }\n          // await block\n          await this._translateLine(line);\n        }\n\n        // add code to macro\n        if (this.isInMacroDefinition()) {\n          let name = this.getCurrentMacroName();\n          this.getMacroDefinition(name).push(line);\n          continue;\n        }\n        lines.push(line);\n      }\n      // remove variable registration if they have been expanded\n      if (expandVariables) {\n        this.__vars = {};\n      }\n      return lines;\n    },\n\n    /**\n     * Returns the lines for the macro of the given name, with the given arguments\n     * replaced (1st arg -> $1, 2nd arg -> $2, etc.). If it doesn't exist,\n     * return undefined.\n     * @param macro_name {String} The name of the macro\n     * @param args {Array} An array of arguments to be replaced in the macro code\n     * @return {Array|undefined}\n     * @private\n     */\n    _getMacro(macro_name, args) {\n      if (!this.macroExists(macro_name)) {\n        return undefined;\n      }\n      let macro_lines = this.getMacroDefinition(macro_name);\n      // argument placeholders\n      for (let i = 0; i < args.length; i++) {\n        macro_lines = macro_lines.map(l => l.replace(new RegExp(\"\\\\$\" + (i + 1), \"g\"), JSON.stringify(args[i])));\n      }\n      return macro_lines;\n    },\n\n\n    /**\n     * Returns an array of lines containing variable declarations\n     * @return {string[]}\n     * @private\n     */\n    _defineVariables() {\n      return Object.getOwnPropertyNames(this.__vars)\n        .map(key => `const ${key} =\"${this.__vars[key]}\";`);\n    },\n\n    /**\n     * Translates variables in a line\n     * @param line {String}\n     * @private\n     * @return {String}\n     * @ignore(args)\n     */\n    _translateVariables(line) {\n      if (line.match(/\\$([^\\s\\d\\/]+)/)) {\n        line = line.replace(/\\$([^\\s\\d\\/]+)/g, (...args) => {\n          let var_name = args[1];\n          let var_content = this.__vars[var_name];\n          if (var_content === undefined) {\n            throw new Error(`Variable '${var_name}' has not been defined.`);\n          }\n          return var_content;\n        });\n      }\n      return line;\n    },\n\n    /**\n     * Returns the code of utility functions needed for the command implementations.\n     * @param script {String} Optional script code to be searched for the function name.\n     * If given, omit function if not present in the script code\n     * @return {string[]}\n     * @private\n     * @ignore(fn)\n     */\n    _generateUtilityFunctionsCode(script) {\n      return Object.entries(this.self(arguments).utilityFunctions)\n        .filter(([name]) => script ? script.match(new RegExp(name)) : true)\n        .map(([name, fn]) => fn.toString()\n          .replace(/function \\(/, `function ${name}(`)\n          // remove comments, see https://stackoverflow.com/questions/5989315/regex-for-match-replacing-javascript-comments-both-multiline-and-inline\n          .replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, \"$1\")\n          .split(/\\n/)\n          .map(line => line.trim())\n          .filter(line => Boolean(line))\n          .join(\"\")\n        );\n    },\n\n    /**\n     * Replays a number of script lines\n     * @param lines {String[]}\n     * @param steps {Integer?}\n     * @param step {Integer?}\n     * @return {Promise<boolean>}\n     * @private\n     */\n    async _play(lines, steps=0, step=0) {\n      for (let line of lines) {\n        // stop if we're not running (user pressed \"stop\" button\n        if (!this.getRunning()) {\n          return false;\n        }\n\n        // ignore comments\n        if (line.startsWith(\"#\")) {\n          continue;\n        }\n\n        // variables\n        line = this._translateVariables(line);\n\n        // play macros recursively\n        let [command, ...args] = this.tokenize(line);\n        let macro_lines = this._getMacro(command, args);\n        if (macro_lines !== undefined) {\n          if (steps) {\n            step++;\n            this.debug(`\\n===== Step ${step} / ${steps}, executing macro ${command} =====`);\n          }\n          await this._play(macro_lines);\n          continue;\n        }\n\n        // count steps if given, wait doesn't count as a step\n        if (steps && !line.startsWith(\"wait\") && !line.startsWith(\"delay\")) {\n          step++;\n          // inform listeners\n          this.fireDataEvent(\"progress\", [step, steps]);\n          this.debug(`\\n===== Step ${step} / ${steps} ====`);\n        }\n        // ignore delay in test mode\n        if (this.getMode() === \"test\" && line.startsWith(\"delay\")) {\n          continue;\n        }\n\n        // translate\n        let code = await this._translateLine(line);\n        // skip empty lines\n        if (!code) {\n          continue;\n        }\n\n        // handle multiple lines from imports\n        if (Array.isArray(code)) {\n          this.debug(`>>>>>>>>> Start import >>>>>>>>>>>>>`);\n          await this._play(code, code.length, 0);\n          this.debug(`<<<<<<<<< End import ><<<<<<<<<<<<<<`);\n          continue;\n        }\n\n        this.debug(`${line}\\n${\"-\".repeat(40)}\\n${code}`);\n        // execute\n        let result = window.eval(code);\n        if (result instanceof Promise) {\n          try {\n            await result;\n          } catch (e) {\n            throw e;\n          }\n        }\n      }\n      return true;\n    },\n\n    /**\n     * Replays the given script of intermediate code\n     * @param scriptOrLines {String|Array}\n     *    The script to replay. If String, assume an unhandled script. If Array,\n     *    assume that script has already been handled by {@link #_handleMeta) and\n     *    split into lines.\n     * @return {Promise} Promise which resolves when the script has been replayed, or\n     * rejects with an error\n     * @todo implement pausing\n     */\n    async replay(scriptOrLines) {\n      this.setRunning(true);\n      let lines = Array.isArray(scriptOrLines) ? scriptOrLines : await this._handleMeta(scriptOrLines);\n      let steps = 0;\n      let await_block= false;\n      for (let line of lines) {\n        if (line.startsWith(\"await-\")) {\n          await_block = true;\n          continue;\n        }\n        if (line.startsWith(\"end\")) {\n          await_block = false;\n          continue;\n        }\n        if (!await_block && !line.startsWith(\"wait \") && !line.startsWith(\"#\") && !line.startsWith(\"delay\")) {\n          steps++;\n        }\n      }\n\n      // replay it!\n      try {\n        await this._play(lines, steps, 0);\n      } catch (e) {\n        switch (this.getMode()) {\n          case \"test\":\n            throw e;\n          case \"presentation\":\n            this.warn(e);\n            qxl.dialog.Dialog.error(e.message);\n        }\n      }\n      this.setRunning(false);\n      qx.event.Timer.once(() => this.cmd_hide_info(), null, 100);\n    },\n\n    /**\n     * Translates the intermediate code into the target language\n     * @param scriptOrLines {String|Array}\n     *    The script to translate.\n     *    If String, assume an unhandled script. If Array. assume that script\n     *    has already been handled by {@link #_handleMeta) and split into lines\n     * @return {string} executable code\n     */\n    async translate(scriptOrLines) {\n      return this._translate(scriptOrLines);\n    },\n\n    /**\n     * Implementation for #translate(). Returns the translated lines.\n     * @param scriptOrLines {String|Array}\n     *    If String, assume an unhandled script. If Array. assume that script\n     *    has already been handled by {@link #_handleMeta) and split into lines\n     * @param includeUtilityFunctions {Boolean}\n     * @return {string}\n     * @private\n     */\n    async _translate(scriptOrLines, includeUtilityFunctions=true) {\n      let lines = Array.isArray(scriptOrLines) ? scriptOrLines : await this._handleMeta(scriptOrLines);\n      let translatedLines = this._defineVariables();\n      for (let line of lines) {\n        line = line.trim();\n        if (!line) {\n          continue;\n        }\n        let [command, ...args] = this.tokenize(line);\n        let macro_lines = this._getMacro(command, args);\n        let new_lines = [];\n        for (let l of (macro_lines || [line])) {\n          let code = await this._translateLine(l);\n          if (Array.isArray(code)) {\n            new_lines = new_lines.concat(code);\n          } else {\n            new_lines.push(code);\n          }\n        }\n        translatedLines = translatedLines.concat(new_lines.filter(l => Boolean(l)));\n      }\n      let translation = translatedLines.join(\"\\n\");\n      if (includeUtilityFunctions) {\n        return this._generateUtilityFunctionsCode(translation)\n          .concat(translatedLines)\n          .join(\"\\n\");\n      }\n      return translation;\n    },\n\n    /**\n     * Given an async piece of code which checks for a condition or an application state,\n     * return code that checks for this condition, throwing an error if the\n     * condition hasn't been fulfilled within the set timeout.\n     * @param condition {String} The condition expression as a string\n     * @param timeoutmsg {String|undefined} An optional message to be shown if the condition hasn't been met before the timeout.\n     */\n    generateWaitForConditionCode(condition, timeoutmsg) {\n      qx.core.Assert.assertString(condition);\n      timeoutmsg = timeoutmsg || `Timeout waiting for condition '${condition}' to fulfil.\"`;\n      return `(waitForCondition(() => ${condition}, ${this.getInterval()}, ${this.getTimeout()}, \"${timeoutmsg}\"))`;\n    },\n\n    /**\n     * Generates code that returns a promise which will resolve (with any potential event data) if the given object fires\n     * an event with the given type and data (if applicable) and will reject if the timeout is reached before that happens.\n     * @param id {String} The id of the object to monitor\n     * @param type {String} The type of the event to wait for\n     * @param data {*|undefined} The data to expect. Must be serializable to JSON. Exception: if the data is a string that\n     * starts with \"{verbatim}\", the unquoted string is used\n     * @param timeoutmsg {String|undefined} An optional message to be shown if the event hasn't been fired before the timeout.\n     * @return {String}\n     */\n    generateWaitForEventCode(id, type, data, timeoutmsg) {\n      qx.core.Assert.assertString(id);\n      qx.core.Assert.assertString(type);\n      if (qx.lang.Type.isString(data) && data.startsWith(\"{verbatim}\")) {\n        data = data.substr(10);\n      } else {\n        data = JSON.stringify(data);\n      }\n      if (!timeoutmsg) {\n        timeoutmsg=`Timeout waiting for event '${type}' on '${id}'`;\n      }\n\n      return `(waitForEvent(\"${id}\", \"${type}\",${data}, ${this.getTimeout()}, \"${timeoutmsg}\"))`;\n    },\n\n    /**\n     * Generates code that returns a promise which will resolve (with any\n     * potential event data) if the given object fires an event with the given\n     * type and data (if applicable). After the timeout, it will execute the\n     * given code and restart the timeout.\n     *\n     * @param id {String} The id of the object to monitor\n     * @param type {String} The type of the event to wait for\n     * @param data {*|null} The data to expect. Must be serializable to JSON. In case\n     * of events that do not have data, you MUST explicitly pass 'undefined' as\n     * argument if you use the following arguments\n     * @param code {String} The code to execute after the timeout\n     * @return {String}\n     */\n    generateWaitForEventTimoutFunction(id, type, data, code) {\n      qx.core.Assert.assertString(id);\n      qx.core.Assert.assertString(type);\n      return `(new Promise(async (resolve, reject) => { \n        while (true){\n          try {\n            await waitForEvent(qx.core.Id.getQxObject(\"${id}\"), \"${type}\", ${data===undefined?\"undefined\":JSON.stringify(data)}, ${this.getTimeout()});\n            return resolve(); \n          } catch (e) {\n            console.debug(e.message);\n            ${code};\n          }\n        }\n      }))`.split(/\\n/).map(l => l.trim()).join(\"\");\n    },\n\n    /**\n     * Adds a line comment to the target script\n     * @param comment {String}\n     * @return {string}\n     */\n    addComment(comment) {\n      return \"// \" + comment;\n    },\n\n    /**\n     * Escapes all characters in a string that are special characters in a regular expression\n     * @param s {String} The string to escape\n     * @return {String}\n     */\n    escapeRegexpChars(s) {\n      return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    },\n\n    /**\n     * Creates a regular expression that matches a json string. In this string, you can use a regular expression\n     * enclosed by \"<!\" and \"!>\" to replace data that cannot be known in advance, such as tokens or session ids.\n     * Example: '{token:\"<![A-Za-z0-9]{32}!>\",user:\"admin\">' will match '{\"token\":\"OnBHqQd59VHZYcphVADPhX74q0Sc6ERR\",\"user\":\"admin\"}'\n     * @param s {string}\n     */\n    createRegexpForJsonComparison(s) {\n      let searchExp = /<![^<][^!]+!>/g;\n      let foundRegExps = s.match(searchExp);\n      if (foundRegExps && foundRegExps.length) {\n        let index=0;\n        // remove escape sequence\n        foundRegExps = foundRegExps.map(m => m.slice(2, -2));\n        // replace placeholders\n        return this.escapeRegexpChars(s).replace(searchExp, () => foundRegExps[index++]);\n      }\n      return this.escapeRegexpChars(s);\n    },\n\n    /**\n     * Adds promise code to a list of promises that need to resolve before the\n     * script proceeds\n     * @param promiseCode\n     */\n    _addPromiseToAwaitStack(promiseCode) {\n      if (!qx.lang.Type.isArray(this.__promises)) {\n        throw new Error(\"Cannot add promise since no await block has been opened.\");\n      }\n      this.__promises.push(promiseCode);\n    },\n\n    /**\n     * Returns the file extension of the downloaded file in the target language\n     * @return {string}\n     */\n    getExportFileExtension() {\n      throw new Error(\"Method getExportFileExtension must be impemented in subclass\");\n    },\n\n    /**\n     * Whether the player is in an await block\n     * @return {Boolean}\n     */\n    isInAwaitBlock() {\n      return qx.lang.Type.isArray(this.__promises);\n    },\n\n    /**\n     * Returns the storage object\n     * @return {qx.bom.storage.Web}\n     * @private\n     */\n    _getStorage() {\n      return qx.bom.storage.Web.getSession();\n    },\n\n    /**\n     * Saves an imported script\n     * @param uri {String}\n     * @param script {String}\n     */\n    _saveImport(uri, script) {\n      this._getStorage().setItem(\"import:\" + uri, script);\n    },\n\n    /**\n     * Retrieves an imported script by its uri, if it exists\n     * @param uri {String}\n     * @return {String}\n     */\n    _getImport(uri) {\n      return this._getStorage().getItem(\"import:\" + uri);\n    },\n\n    /**\n     * Removes all imported scripts\n     */\n    _clearImports() {\n      this._getStorage().forEach(key => {\n        if (key.startsWith(\"import:\")) {\n          this._getStorage().removeItem(key);\n        }\n      });\n    },\n\n    /*\n    ============================================================================\n       COMMANDS\n    ============================================================================\n    */\n\n    /**\n     * Imports a remote file and caches it locally\n     * @param uri {String}\n     * @return {Promise<array>}\n     */\n    async cmd_import(uri) {\n      const [type, id] = uri.split(\":\");\n      if (type !== \"gist\") {\n        throw new Error(\"Currently, only gists can be imported.\");\n      }\n      // use stored script or load from URI\n      let remoteScript = this._getImport(uri);\n      if (!remoteScript) {\n        remoteScript = await this.getRawGist(id);\n        this._saveImport(uri, remoteScript);\n      }\n      return this._translate(remoteScript, false);\n    },\n\n    /**\n     * Clears locally cached imported scripts in order to force-reload them\n     */\n    cmd_clear_imports() {\n      this._clearImports();\n      return \"\";\n    },\n\n    /**\n     * Asserts that the current url matches the given value (RegExp)\n     * @param uri {String}\n     */\n    cmd_assert_uri(uri) {\n      return `qx.core.Assert.assertEquals(window.location.href, \"${uri}\", \"Script is valid on '${uri}' only'\")`;\n    },\n\n    /**\n     * Asserts that the current url matches the given value (RegExp)\n     * @param uri_regexp {String} A string containing a regular expression\n     */\n    cmd_assert_match_uri(uri_regexp) {\n      if (this.getMode()===\"presentation\") {\n        return `if(!window.location.href.match(new RegExp(\"${uri_regexp}\"))){alert(\"The eventrecorder script is meant to be played on a website that matches '${uri_regexp}'.\");window[\"${this._globalRef}\"].stop();}`;\n      }\n      return `qx.core.Assert.assertMatch(window.location.href, \"${uri_regexp}\", \"Current URL does not match '${uri_regexp}'\")`;\n    },\n\n    /**\n     * Sets the player mode\n     * @param mode\n     * @return {string}\n     */\n    cmd_config_set_mode(mode) {\n      return `window[\"${this._globalRef}\"].setMode(\"${mode}\");`;\n    },\n\n    /**\n     * Starts the definition of a macro\n     * @param macro_name {String}\n     * @param macro_description {String|undefined}\n     * @return {null}\n     */\n    cmd_define(macro_name, macro_description) {\n      if (this.macroExists(macro_name)) {\n        throw new Error(`Cannot define macro '${macro_name}' since a macro of that name already exists.`);\n      }\n      this.addMacro(macro_name, macro_description);\n      this.beginMacroDefintion(macro_name);\n      return null;\n    },\n\n    /**\n     * Ends the definition of a macro or a block of awaitable statements\n     * @return {null}\n     */\n    cmd_end() {\n      if (this.__promises) {\n        let line = this.__promises.length ? `(Promise.all([${this.__promises.join(\",\")}]))` : null;\n        this.__promises = null;\n        return line;\n      }\n      if (this.__macro_stack_index < 0) {\n        throw new Error(`Unexpected 'end'.`);\n      }\n      this.leaveMacroDefinition();\n      return null;\n    },\n\n    /**\n     * Starts a block of statements that return promises. The player will wait for\n     * all of the promises to resolve before proceeding.\n     */\n    cmd_await_all() {\n      this.__promises=[];\n      return null;\n    }\n  }\n});\n"
  ]
}